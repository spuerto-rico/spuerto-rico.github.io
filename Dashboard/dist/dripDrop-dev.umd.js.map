{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d0c4bca2309bd73822f8","webpack:///./drip-drop/~/proto/proto.js","webpack:///./drip-drop/~/emitter-b/src/EmitterB.js","webpack:///./drip-drop/drag.js","webpack:///./drip-drop/drop.js","webpack:///./drip-drop/drip-drop.js","webpack:///./drip-drop/~/events/events.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;AChEA;AACA;;AAEA;;AAEA,kGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;;AAEA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,C;;;;;;;;;;;ACnIA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,SAAS;AACT;AACA,2CAA2C;AAC3C,SAAS;AACT,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,gCAAgC;AACpD;AACA;AACA;;AAEA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;ACnNA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,UAAU;;AAElC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,iEAAiE;AACjE;AACA,KAAK;AACL,C;;;;;;;;;;;ACrGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACnNA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,GAAG;;;;;;;;;;;;;;ACvCH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"dripDrop-dev.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dripDrop\"] = factory();\n\telse\n\t\troot[\"dripDrop\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d0c4bca2309bd73822f8","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                },\r\n                configurable: true // so you can change it if you want\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/~/proto/proto.js\n// module id = 0\n// module chunks = 0","var EventEmitter = require('events').EventEmitter\nvar proto = require(\"proto\")\n\nmodule.exports = proto(EventEmitter, function(superclass) {\n\n    this.init = function() {\n        superclass.apply(this, arguments)\n\n        this.ifonHandlers = {}\n        this.ifoffHandlers = {}\n        this.ifonAllHandlers = []\n        this.ifoffAllHandlers = []\n    }\n\n    // callback will be triggered immediately if there is already a listener attached, or\n    // callback will be triggered when the first listener for the event is added\n    // (regardless of whether its done through on or once)\n    // parameters can be:\n        // event, callback - attach an ifon handler for the passed event\n        // callback - attach an ifon handler for all events\n    this.ifon = function(event, callback) {\n        if(event instanceof Function) {     // event not passed, only a callback\n            callback = event // fix the argument\n            for(var eventName in this._events) {\n                if(this.listeners(eventName).length > 0) {\n                    callback(eventName)\n                }\n            }\n        } else if(this.listeners(event).length > 0) {\n            callback(event)\n        }\n\n        addHandlerToList(this, 'ifonHandlers', event, callback)\n    }\n\n    // removes either:\n        // removeIfon() - all ifon handlers (if no arguments are passed), or\n        // removeIfon(event) - all ifon handlers for the passed event, or\n        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\n        // removeIfon(event, callback) - the specific passed callback for the passed event\n    this.removeIfon = function(event, callback) {\n        removeFromHandlerList(this, 'ifonHandlers', event, callback)\n    }\n\n    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\n    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\n    // parameters can be:\n        // event, callback - attach an ifoff handler for the passed event\n        // callback - attach an ifoff handler for all events\n    this.ifoff = function(event, callback) {\n        addHandlerToList(this, 'ifoffHandlers', event, callback)\n    }\n\n    // removes either:\n        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\n        // removeIfoff(event) - all ifoff handlers for the passed event, or\n        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\n        // removeIfoff(event, callback) - the specific passed callback for the passed event\n    this.removeIfoff = function(event, callback) {\n        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\n    }\n\n    // emitter is the emitter to proxy handler binding to\n    // options can have one of the following properties:\n        // only - an array of events to proxy\n        // except - an array of events to *not* proxy\n    this.proxy = function(emitter, options) {\n        if(options === undefined) options = {}\n        if(options.except !== undefined) {\n            var except = arrayToMap(options.except)\n            var handleIt = function(event){return !(event in except)}\n        } else if(options.only !== undefined) {\n            var only = arrayToMap(options.only)\n            var handleIt = function(event){return event in only}\n        } else {\n            var handleIt = function(){return true}\n        }\n\n        var that = this, handler;\n        this.ifon(function(event) {\n            if(handleIt(event)) {\n                emitter.on(event, handler = function() {\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n                })\n            }\n        })\n        this.ifoff(function(event) {\n            if(handleIt(event))\n                emitter.off(event, handler)\n        })\n    }\n\n    /*override*/ this.on = this.addListener = function(event, callback) {\n        var triggerIfOn = this.listeners(event).length === 0\n        superclass.prototype.on.apply(this,arguments)\n        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\n    }\n\n    /*override*/ this.off = this.removeListener = function(event, callback) {\n        var triggerIfOff = this.listeners(event).length === 1\n        superclass.prototype.removeListener.apply(this,arguments)\n        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\n    }\n    /*override*/ this.removeAllListeners = function(event) {\n        var triggerIfOffForEvents = []\n        if(event !== undefined) {\n            if(this.listeners(event).length > 0) {\n                triggerIfOffForEvents.push(event)\n            }\n        } else {\n            for(var event in this._events) {\n                if(this.listeners(event).length > 0) {\n                    triggerIfOffForEvents.push(event)\n                }\n            }\n        }\n\n        superclass.prototype.removeAllListeners.apply(this,arguments)\n\n        for(var n=0; n<triggerIfOffForEvents.length; n++) {\n            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\n        }\n    }\n\n})\n\n\n// triggers the if handlers from the normal list and the \"all\" list\nfunction triggerIfHandlers(that, handlerListName, event) {\n    triggerIfHandlerList(that[handlerListName][event], event)\n    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\n}\n\n\n// triggers the if handlers from a specific list\n// ya these names are confusing, sorry : (\nfunction triggerIfHandlerList(handlerList, event) {\n    if(handlerList !== undefined) {\n        for(var n=0; n<handlerList.length; n++) {\n            handlerList[n](event)\n        }\n    }\n}\n\nfunction addHandlerToList(that, handlerListName, event, callback) {\n    if(event instanceof Function) {\n        // correct arguments\n        callback = event\n        event = undefined\n    }\n\n    if(event !== undefined && callback !== undefined) {\n        var handlerList = that[handlerListName][event]\n        if(handlerList === undefined) {\n            handlerList = that[handlerListName][event] = []\n        }\n\n        handlerList.push(callback)\n    } else {\n        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\n    }\n}\n\nfunction removeFromHandlerList(that, handlerListName, event, callback) {\n    if(event instanceof Function) {\n        // correct arguments\n        callback = event\n        event = undefined\n    }\n\n    if(event !== undefined && callback !== undefined) {\n        removeCallbackFromList(that[handlerListName][event], callback)\n    } else if(event !== undefined) {\n        delete that[handlerListName][event]\n    } else if(callback !== undefined) {\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\n        removeCallbackFromList(that[allHandlerListName], callback)\n    } else {\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\n        that[handlerListName] = {}\n        that[allHandlerListName] = []\n    }\n}\n\nfunction normalHandlerToAllHandlerProperty(handlerListName) {\n    if(handlerListName === 'ifonHandlers')\n        return 'ifonAllHandlers'\n    if(handlerListName === 'ifoffHandlers')\n        return 'ifoffAllHandlers'\n}\n\nfunction removeCallbackFromList(list, callback) {\n    var index = list.indexOf(callback)\n    list.splice(index,1)\n}\n\nfunction getTrace() {\n    try {\n        throw new Error()\n    } catch(e) {\n        return e\n    }\n}\n\n// turns an array of values into a an object where those values are all keys that point to 'true'\nfunction arrayToMap(array) {\n    var result = {}\n    array.forEach(function(v) {\n        result[v] = true\n    })\n    return result\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/~/emitter-b/src/EmitterB.js\n// module id = 1\n// module chunks = 0","var EmitterB = require(\"emitter-b\")\r\nvar proto = require(\"proto\")\r\n\r\n// node - The dom node to set as a drag handle\r\n// options\r\n    // image - Can take on one of the following possible values:\r\n        // false - (Default) No image\r\n        // true - The default generated drag image\r\n        // string - The path to an image\r\n        // imageObject - If this is an Image object, that will be used\r\n// Events:\r\n    // start(setData, e) - Emitted when dragging starts. Use setData to set the data for each type.\r\n        // setData(type, data) - Sets data for a particular type.\r\n            // NOTE: In an attempt mitigate type lowercasing weirdness, capitals will be converted to dash-lowercase *and* lowercase without dashes\r\n            // IE NOTE: IE is a piece of shit and doesn't allow any 'type' other than \"text\" and \"url\" - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/329509/\r\n    // move(pointerPosition, e)\r\n    // end(e)\r\nvar drag = module.exports = proto(EmitterB, function(superclass) {\r\n    this.init = function(node, options) {\r\n        var that = this\r\n        superclass.init.call(this)\r\n\r\n        if(!options) options = {}\r\n        node.setAttribute(\"draggable\", \"true\")\r\n\r\n        var dragInfo = {node:node}, moveHandlerExists = false\r\n\r\n        this.ifon('start', function() {\r\n            node.addEventListener('dragstart', dragInfo.start = function(e) {\r\n                if(options.image !== undefined) {\r\n                    if(options.image !== true) { // if its true, leave the default drag image\r\n                        if(typeof(options.image) === 'string') {\r\n                            var image = new Image(options.image)\r\n                        } else {\r\n                            var image = options.image\r\n                        }\r\n\r\n                        e.dataTransfer.setDragImage(image, image.width,image.height)\r\n                    }\r\n                } else {\r\n                    e.dataTransfer.setDragImage(new Image, 0,0) // no image\r\n                }\r\n\r\n                var dataTransfer = e.dataTransfer\r\n                that.emit('start', function(type, string) {\r\n                    dataTransfer.setData(type, string)\r\n                    var mappedType = mapFromCamelCase(type)\r\n                    if(mappedType !== type) {\r\n                        dataTransfer.setData(mappedType, string)\r\n                    }\r\n                }, e)\r\n\r\n                if(moveHandlerExists) {\r\n                    var recentMousePos\r\n                    document.addEventListener('dragover', dragInfo.docOver = function(e) {\r\n                        if(recentMousePos === undefined || e.pageX !== recentMousePos.x || e.pageY !== recentMousePos.y) {\r\n                            recentMousePos = {x:e.pageX,  y:e.pageY}\r\n                            that.emit('move', e)\r\n                        }\r\n                    }, true)\r\n\r\n                    node.addEventListener('dragend', function dragendHandler() {\r\n                        document.removeEventListener('dragover', dragInfo.docOver, true)\r\n                        dragInfo.node.removeEventListener('dragend', dragendHandler)\r\n                    })\r\n                }\r\n            })\r\n        })\r\n\r\n        this.ifon('move', function() {\r\n            moveHandlerExists = true\r\n        })\r\n\r\n        this.ifon('end', function() {\r\n            node.addEventListener('dragend', dragInfo.end = function(e) {\r\n                that.emit('end', e)\r\n            })\r\n        })\r\n\r\n        this.ifoff('start', function() {\r\n            dragInfo.node.removeEventListener('dragstart', dragInfo.start)\r\n        })\r\n        this.ifoff('move', function() {\r\n            moveHandlerExists = false\r\n            if(dragInfo.docOver) document.removeEventListener('dragover', dragInfo.docOver, true)\r\n        })\r\n        this.ifoff('end', function() {\r\n            dragInfo.node.removeEventListener('dragend', dragInfo.end)\r\n        })\r\n\r\n        // deprecated\r\n        if(options.start) this.on('start', options.start)\r\n        if(options.move) this.on('move', options.move)\r\n        if(options.end) this.on('end', options.end)\r\n    }\r\n})\r\n\r\nfunction mapFromCamelCase(string) {\r\n    return string.replace(/([A-Z])/g, function(match, submatch) {          // this is from jss\r\n        return '-' + submatch.toLowerCase()\r\n    })\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/drag.js\n// module id = 2\n// module chunks = 0","var EmitterB = require(\"emitter-b\")\r\nvar proto = require(\"proto\")\r\n\r\n// node - The node to set up as a drop zone\r\n// options - An object with the optional members:\r\n    // allow - A list of types to allow the event handlers be called for.\r\n            // If this is passed and the current drag operation doesn't have an allowed type, the handlers will not be called.\r\n            // If this isn't passed, all types are allowed.\r\n// Events:\r\n    // enter(types, e) - Emitted when a drag action enters the node\r\n        // types - The data types available on drop\r\n    // move(types, e) - Emitted when the dragging pointer moves over the node\r\n        // IMPORTANT: 'data' will contain the correct keys, but will *not* actually contain any data. Blame the stupid html5 drag and drop api.\r\n    // leave(types, e) - Emitted when the dragging pointer moves out of the node\r\n    // in(types, e) - Emitted when the dragging pointer crosses in over a child-boundary of a descendant node that is also a drop zone\r\n    // out(types, e) - Emitted when the dragging pointer crosses out over a child-boundary of a descendant node that is also a drop zone\r\n    // drop(data, e) - Emitted when the dragging pointer releases above the node\r\n        // data - An object where each key is a data type, where if that type contains dashes, the type will be available as is *and* with dash-lowercase converted to camel case\r\n            // The value is either:\r\n             // For the 'Files' type, the value is a list of files, each with a set of properties described here: https://developer.mozilla.org/en-US/docs/Web/API/File .\r\n              // In addition, the files have the methods:\r\n                // getText(errback) - Returns the text of the file in a call to the the errback\r\n                // getBuffer(errback) - Returns a Buffer of the file contents in a call to the the errback\r\n             // For any other type, the value is a string of data in a format depending on the type\r\nvar drop = module.exports = proto(EmitterB, function(superclass) {\r\n\r\n    this.init = function (node, options) {\r\n        var that = this\r\n        superclass.init.call(this)\r\n        if(!options) options = {}\r\n\r\n        if (options.allow) {\r\n            var allowed = options.allow\r\n            var isAllowed = function (types) {\r\n                for (var n = 0; n < allowed.length; n++) {\r\n                    if (types.indexOf(allowed[n]) !== -1) {\r\n                        return true\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n        } else {\r\n            var isAllowed = function () {\r\n                return true\r\n            }\r\n        }\r\n\r\n        var dropInfo = {node: node}, curTypes, dragCounter = 0\r\n\r\n        this.ifon('move',function() {\r\n            var recentMousePos, stopPropCalled;\r\n            node.addEventListener('dragover', dropInfo.over = function (e) {\r\n                var originalStopProp = e.stopPropagation\r\n                e.stopPropagation = function () {\r\n                    stopPropCalled = true\r\n                }\r\n\r\n                if (recentMousePos === undefined || e.pageX !== recentMousePos.x || e.pageY !== recentMousePos.y) {\r\n                    recentMousePos = {x: e.pageX, y: e.pageY}\r\n                    if (isAllowed(curTypes)) {\r\n                        stopPropCalled = false\r\n                        that.emit('move', curTypes, e)\r\n                    }\r\n                }\r\n\r\n                if (stopPropCalled) {\r\n                    originalStopProp.call(e)\r\n                }\r\n            })\r\n        })\r\n\r\n\r\n        this.ifon('drop',function() {\r\n            node.addEventListener('drop', dropInfo.drop = function (e) {\r\n                e.preventDefault()\r\n                if (isAllowed(curTypes)) {\r\n                    var data = buildDataObject(e.dataTransfer)\r\n                    that.emit('drop', data, e)\r\n                }\r\n            })\r\n        })\r\n\r\n        var activeEvents = {}\r\n        this.ifon(function(event) {\r\n            activeEvents[event] = true\r\n            if(anyEventActive(activeEvents)) {\r\n                node.addEventListener('dragenter', dropInfo.enter = function (e) {\r\n                    dragCounter++\r\n                    if (dragCounter === 1) { // browsers stupidly emits dragenter whenever crossing over a child boundary..\r\n                        var data = buildDataObject(e.dataTransfer)\r\n                        curTypes = Object.keys(data)\r\n                        if (isAllowed(curTypes)) {\r\n                            that.emit('enter', curTypes, e)\r\n                        }\r\n                    } else {\r\n                        that.emit('in',curTypes, e)\r\n                    }\r\n                })\r\n\r\n                node.addEventListener('dragleave', dropInfo.leave = function (e) {\r\n                    dragCounter--\r\n                    if (dragCounter === 0) { // browsers stupidly emits dragleave whenever crossing over a child boundary..\r\n                        if(isAllowed(curTypes))\r\n                            that.emit('leave', curTypes, e)\r\n                    } else {\r\n                        that.emit('out', curTypes, e)\r\n                    }\r\n                })\r\n\r\n                node.addEventListener('drop', dropInfo.enterLeaveDropHandler = function (e) {\r\n                    dragCounter = 0 // reset\r\n                }, true) // capture event to ensure this happens regardless of stop propogation calls\r\n            }\r\n        })\r\n        this.ifoff(function(event) {\r\n            activeEvents[event] = false\r\n            if(!anyEventActive(activeEvents)) {\r\n                dropInfo.node.removeEventListener('dragenter', dropInfo.start)\r\n                dropInfo.node.removeEventListener('dragleave', dropInfo.end)\r\n                dropInfo.node.removeEventListener('drop', dropInfo.enterLeaveDropHandler)\r\n            }\r\n        })\r\n\r\n        this.ifoff('move', function() {\r\n            dropInfo.node.removeEventListener('dragover', dropInfo.over)\r\n        })\r\n        this.ifoff('drop', function() {\r\n            dropInfo.node.removeEventListener('drop', dropInfo.drop)\r\n        })\r\n\r\n        // deprecated\r\n        if(options.enter) this.on('enter', options.enter)\r\n        if(options.move) this.on('move', options.move)\r\n        if(options.leave) this.on('leave', options.leave)\r\n        if(options.in) this.on('in', options.in)\r\n        if(options.out) this.on('out', options.out)\r\n        if(options.drop) this.on('drop', options.drop)\r\n    }\r\n})\r\n\r\nfunction anyEventActive(activeEvents) {\r\n    for(var k in activeEvents) {\r\n        if(activeEvents[k]) return true\r\n    }\r\n    // else\r\n    return false\r\n}\r\n\r\nfunction readTextFile(file, type, cb){\r\n    var reader=new FileReader()\r\n    reader.onloadend=function(e) {\r\n        if(e.target.readyState==FileReader.DONE){\r\n            cb(undefined, reader.result)\r\n        }\r\n    }\r\n    reader.onerror = function(e) {\r\n        cb(e)\r\n    }\r\n    reader[type](file)\r\n}\r\n\r\nfunction buildDataObject(dt) {\r\n    var data = {}\r\n    if(dt.files.length > 0) {\r\n        data.Files = dt.files\r\n    }\r\n    for(var j=0; j<dt.types.length; j++) {\r\n        var type = dt.types[j]\r\n        if(type === 'Files') {\r\n            data.Files = dt.files\r\n            for(var n=0;n<data.Files.length;n++) {\r\n                var file = data.Files[n]\r\n                file.getText = function(cb) {\r\n                    readTextFile(file, 'readAsText', cb)\r\n                }\r\n                file.getBuffer = function(cb) {\r\n                    readTextFile(file, 'readAsArrayBuffer', cb)\r\n                }\r\n            }\r\n        } else {\r\n            attachGetter(data, dt, type)\r\n            var mappedType = mapToCamelCase(type)\r\n            if(mappedType !== type) {\r\n                attachGetter(data, dt, mappedType)\r\n            }\r\n        }\r\n    }\r\n\r\n    return data\r\n}\r\n\r\nfunction attachGetter(data, dt, type) {\r\n    Object.defineProperty(data, type, {\r\n        enumerable: true,\r\n        get: function() {\r\n            return dt.getData(type)\r\n        }\r\n    })\r\n}\r\n\r\nfunction mapToCamelCase(string) {\r\n    return string.replace(/(-[a-z])/g, function(match, submatch) {\r\n        return submatch[1].toUpperCase()\r\n    })\r\n}\r\n\r\n// returns true if the point intersects the element's bounds, false otherwise\r\nfunction pointerIsOver(x,y, element) {\r\n    var bounds = element.getBoundingClientRect()\r\n    return bounds.top <= y&&y <= bounds.bottom\r\n        && bounds.left <= x&&x <= bounds.right\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/drop.js\n// module id = 3\n// module chunks = 0","exports.drop = require('./drop')\r\nexports.drag = require('./drag')\r\n\r\nexports.dontPreventDefault = function() {\r\n    document.removeEventListener('dragenter', docEnterHandler, true)\r\n    document.removeEventListener('dragover', docOverHandler, true)\r\n}\r\n\r\n\r\n// returns an opaque clone of the passed dom node ready to be moved with moveToMouse\r\nexports.ghostItem = function(domNode, zIndex) {\r\n    if(zIndex === undefined) zIndex = 1000\r\n\r\n    var aClone = domNode.cloneNode(true)\r\n    aClone.style.position = 'absolute'\r\n    aClone.style.top = '-100px'\r\n    aClone.style.width = domNode.clientWidth+'px'\r\n    aClone.style.opacity = '.6'\r\n    aClone.style.pointerEvents = 'none' // makes this 'invisible' to mouse events so it doesn't block mouse events while you're dragging it around\r\n    aClone.style['z-index'] = zIndex\r\n\r\n    return aClone\r\n}\r\n// moves an absolutely positioned element to the position by x and y\r\nexports.moveAbsoluteNode = function(node, x, y) {\r\n    node.style.left = x+'px'\r\n    node.style.top = y+'px'\r\n}\r\n\r\n// get rid of the need to do this for other drag events\r\nvar docEnterHandler, docOverHandler;\r\ndocument.addEventListener('dragenter',docEnterHandler=function(e){\r\n    e.preventDefault()\r\n}, true)\r\ndocument.addEventListener('dragover',docOverHandler=function(e){\r\n    e.preventDefault()\r\n}, true)\r\n//document.addEventListener('dragstart',docOverHandler=function(e){\r\n//    e.preventDefault()\r\n//})\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/drip-drop.js\n// module id = 4\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./drip-drop/~/events/events.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}